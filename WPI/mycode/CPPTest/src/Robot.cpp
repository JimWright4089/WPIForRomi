// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include <stdio.h>
#include "Robot.h"

using namespace frc;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<SimpleSubsystem> Robot::simpleSubsystem;
std::unique_ptr<OI> Robot::oi;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
    RobotMap::init();
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    simpleSubsystem.reset(new SimpleSubsystem());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    // This MUST be here. If the OI creates Commands (which it very likely
    // will), constructing it during the construction of CommandBase (from
    // which commands extend), subsystems are not guaranteed to be
    // yet. Thus, their requires() statements may grab null pointers. Bad
    // news. Don't move it.
    oi.reset(new OI());
    buzzer = new frc::RomiBuzzer(I2C::Port::kOnboard, 0x08);
    leftEncoder = new frc::RomiEncoder(I2C::Port::kOnboard, 0x08);
    rightEncoder = new frc::RomiEncoder(I2C::Port::kOnboard, 0x08);
    rightEncoder->SetLeftEncoder(false);

    leftMotor = new frc::RomiMotor(I2C::Port::kOnboard, 0x08);
    rightMotor = new frc::RomiMotor(I2C::Port::kOnboard, 0x08);
    rightMotor->SetLeftMotor(false);

    //drive = new RobotDrive(leftMotor, rightMotor);

    // instantiate the command used for the autonomous period
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
    autonomousCommand.reset(new AutonomousCommand());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
}

/**
* This function is called when the disabled button is hit.
* You can use it to reset subsystems before shutting down.
*/
void Robot::DisabledInit() {
}

void Robot::DisabledPeriodic() {
    Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
    if (autonomousCommand.get() != nullptr)
    {
        autonomousCommand->Start();
    }
    buzzer->PlayTone(0x702,0x20C);
}

int oldLeftEncoder = 0;
int oldRightEncoder = 0;

void Robot::AutonomousPeriodic() {
    Scheduler::GetInstance()->Run();
    int leftEncoderValue = leftEncoder->Get();
    int rightEncoderValue = rightEncoder->Get();

    if ((leftEncoderValue != oldLeftEncoder) || (rightEncoderValue != oldRightEncoder))
    {
        printf("encoder:%d %d\n", leftEncoderValue, rightEncoderValue);
        oldLeftEncoder = leftEncoderValue;
        oldRightEncoder = rightEncoderValue;
    } 
}

void Robot::TeleopInit() {
    // This makes sure that the autonomous stops running when
    // teleop starts running. If you want the autonomous to
    // continue until interrupted by another command, remove
    // these lines or comment it out.
    if (autonomousCommand.get() != nullptr)
    {
        autonomousCommand->Cancel();
    }
    leftMotor->Set(0.0);
    rightMotor->Set(0.0);
}

void Robot::TeleopPeriodic() {
    Scheduler::GetInstance()->Run();
}

void Robot::TestInit() 
{
}

float oldX = 0.0;
float oldY = 0.0;

void Robot::TestPeriodic() 
{
    float curLeftX = Robot::oi->getSimpleStick()->GetRawAxis(0);
    float curLeftY = Robot::oi->getSimpleStick()->GetRawAxis(1);
    float curRightY = Robot::oi->getSimpleStick()->GetRawAxis(3);

    if ((oldX != curLeftX) || (oldY != curLeftY))
    {
        printf("stick:%f %f\n", curLeftX, curLeftY);
        oldX = curLeftX;
        oldY = curLeftY;
    }

    leftMotor->Set(curLeftY);
    rightMotor->Set(curRightY);
    //drive->Drive(Robot::oi->getSimpleStick());
    //drive->ArcadeDrive(curX, curY);

    lw->Run();
}

START_ROBOT_CLASS(Robot)

